// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import { Test } from "forge-std/Test.sol";
import { CommentManager } from "../src/CommentManager.sol";
import { Comments } from "../src/types/Comments.sol";
import { ChannelManager } from "../src/ChannelManager.sol";
import { ICommentManager } from "../src/interfaces/ICommentManager.sol";
import { BaseHook } from "../src/hooks/BaseHook.sol";
import { Hooks } from "../src/types/Hooks.sol";
import { Metadata } from "../src/types/Metadata.sol";
import { TestUtils } from "./utils.sol";
import {
  IERC721Receiver
} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

contract BatchOperationExploitsTest is Test, IERC721Receiver {
  CommentManager public comments;
  ChannelManager public channelManager;

  address public owner;
  address public author;
  address public app;
  address public attacker;
  uint256 public authorPrivateKey = 0x1;
  uint256 public appPrivateKey = 0x2;
  uint256 public attackerPrivateKey = 0x4;

  function setUp() public {
    owner = address(this);
    author = vm.addr(authorPrivateKey);
    app = vm.addr(appPrivateKey);
    attacker = vm.addr(attackerPrivateKey);

    (comments, channelManager) = TestUtils.createContracts(owner);

    vm.deal(author, 100 ether);
    vm.deal(app, 100 ether);
    vm.deal(attacker, 100 ether);
  }

  function test_EmptyBatchOperations_ShouldFail() public {
    Comments.BatchOperation[]
      memory emptyOperations = new Comments.BatchOperation[](0);

    vm.prank(author);
    vm.expectRevert();
    comments.batchOperations{ value: 0 }(emptyOperations);
  }

  function test_ValueMismatchInBatch_ShouldFail() public {
    Comments.CreateComment memory commentData = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");
    bytes32 commentId = comments.getCommentId(commentData);
    bytes memory appSignature = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      commentId
    );

    Comments.BatchOperation[] memory operations = new Comments.BatchOperation[](
      1
    );
    operations[0] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT,
      value: 1 ether, // Claims to need 1 ether
      data: abi.encode(commentData),
      signatures: new bytes[](1)
    });
    operations[0].signatures[0] = appSignature;

    // Send less value than operations claim to need
    vm.prank(author);
    vm.expectRevert();
    comments.batchOperations{ value: 0.5 ether }(operations);
  }

  function test_ExcessiveValueInBatch_ShouldRefund() public {
    Comments.CreateComment memory commentData = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");
    bytes32 commentId = comments.getCommentId(commentData);
    bytes memory appSignature = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      commentId
    );

    Comments.BatchOperation[] memory operations = new Comments.BatchOperation[](
      1
    );
    operations[0] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT,
      value: 0, // No value needed
      data: abi.encode(commentData),
      signatures: new bytes[](1)
    });
    operations[0].signatures[0] = appSignature;

    // Send excess value
    vm.prank(author);
    vm.expectRevert();
    comments.batchOperations{ value: 1 ether }(operations);
  }

  function test_InvalidSignatureCountInBatch_ShouldFail() public {
    Comments.CreateComment memory commentData = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");

    Comments.BatchOperation[] memory operations = new Comments.BatchOperation[](
      1
    );
    operations[0] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT_WITH_SIG,
      value: 0,
      data: abi.encode(commentData),
      signatures: new bytes[](1) // Should need 2 signatures for POST_COMMENT_WITH_SIG
    });

    vm.prank(author);
    vm.expectRevert();
    comments.batchOperations{ value: 0 }(operations);
  }

  function test_MixedOperationTypesValueDistribution() public {
    // Test mixed operation types with proper value distribution
    Comments.CreateComment memory commentData1 = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");
    Comments.CreateComment memory commentData2 = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");
    commentData1.content = "First comment";
    commentData2.content = "Second comment";

    bytes32 commentId1 = comments.getCommentId(commentData1);
    bytes32 commentId2 = comments.getCommentId(commentData2);

    bytes memory appSignature1 = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      commentId1
    );
    bytes memory authorSignature2 = TestUtils.signEIP712(
      vm,
      authorPrivateKey,
      commentId2
    );
    bytes memory appSignature2 = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      commentId2
    );

    Comments.BatchOperation[] memory operations = new Comments.BatchOperation[](
      2
    );

    // First operation: POST_COMMENT (needs 1 signature)
    operations[0] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT,
      value: 0.1 ether,
      data: abi.encode(commentData1),
      signatures: new bytes[](1)
    });
    operations[0].signatures[0] = appSignature1;

    // Second operation: POST_COMMENT_WITH_SIG (needs 2 signatures)
    operations[1] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT_WITH_SIG,
      value: 0.2 ether,
      data: abi.encode(commentData2),
      signatures: new bytes[](2)
    });
    operations[1].signatures[0] = authorSignature2;
    operations[1].signatures[1] = appSignature2;

    vm.prank(author);
    comments.batchOperations{ value: 0.3 ether }(operations);

    // Verify both comments were created
    Comments.Comment memory stored1 = comments.getComment(commentId1);
    Comments.Comment memory stored2 = comments.getComment(commentId2);

    assertEq(
      stored1.content,
      "First comment",
      "First comment should be created"
    );
    assertEq(
      stored2.content,
      "Second comment",
      "Second comment should be created"
    );
  }

  function test_DependentOperationsSequence() public {
    // Test sequence where later operations depend on earlier ones

    // First: Create a comment
    Comments.CreateComment memory parentComment = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");
    parentComment.content = "Parent comment";
    bytes32 parentId = comments.getCommentId(parentComment);
    bytes memory parentSignature = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      parentId
    );

    // Second: Create reply to the first comment
    Comments.CreateComment memory replyComment = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");
    replyComment.content = "Reply comment";
    replyComment.parentId = parentId;
    bytes32 replyId = comments.getCommentId(replyComment);
    bytes memory replySignature = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      replyId
    );

    Comments.BatchOperation[] memory operations = new Comments.BatchOperation[](
      2
    );

    operations[0] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT,
      value: 0,
      data: abi.encode(parentComment),
      signatures: new bytes[](1)
    });
    operations[0].signatures[0] = parentSignature;

    operations[1] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT,
      value: 0,
      data: abi.encode(replyComment),
      signatures: new bytes[](1)
    });
    operations[1].signatures[0] = replySignature;

    vm.prank(author);
    comments.batchOperations{ value: 0 }(operations);

    // Verify both comments were created with correct relationship
    Comments.Comment memory storedParent = comments.getComment(parentId);
    Comments.Comment memory storedReply = comments.getComment(replyId);

    assertEq(
      storedParent.content,
      "Parent comment",
      "Parent comment should be created"
    );
    assertEq(
      storedReply.content,
      "Reply comment",
      "Reply comment should be created"
    );
    assertEq(storedReply.parentId, parentId, "Reply should reference parent");
  }

  function test_MaximumBatchSize_ShouldHandleGracefully() public {
    // Test with large batch size (may hit gas limits)
    uint256 batchSize = 50;
    Comments.BatchOperation[] memory operations = new Comments.BatchOperation[](
      batchSize
    );

    for (uint256 i = 0; i < batchSize; i++) {
      Comments.CreateComment memory commentData = TestUtils
        .generateDummyCreateComment(author, app, "Test comment");
      commentData.content = string(
        abi.encodePacked("Comment ", vm.toString(i))
      );
      bytes32 commentId = comments.getCommentId(commentData);
      bytes memory appSignature = TestUtils.signEIP712(
        vm,
        appPrivateKey,
        commentId
      );

      operations[i] = Comments.BatchOperation({
        operationType: Comments.BatchOperationType.POST_COMMENT,
        value: 0,
        data: abi.encode(commentData),
        signatures: new bytes[](1)
      });
      operations[i].signatures[0] = appSignature;
    }

    vm.prank(author);
    try comments.batchOperations{ value: 0 }(operations) {
      // If successful, verify some comments were created
      // (may not complete all due to gas limits)
    } catch {
      // Expected to fail due to gas limits
    }
  }

  function test_InvalidOperationType_ShouldFail() public {
    Comments.CreateComment memory commentData = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");

    Comments.BatchOperation[] memory operations = new Comments.BatchOperation[](
      1
    );
    operations[0] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.DELETE_COMMENT_WITH_SIG, // Use valid enum
      value: 0,
      data: hex"deadbeef", // Invalid data for this operation type
      signatures: new bytes[](1)
    });

    vm.prank(author);
    vm.expectRevert();
    comments.batchOperations{ value: 0 }(operations);
  }

  function test_MalformedOperationData_ShouldFail() public {
    Comments.BatchOperation[] memory operations = new Comments.BatchOperation[](
      1
    );
    operations[0] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT,
      value: 0,
      data: hex"deadbeef", // Invalid data
      signatures: new bytes[](1)
    });
    operations[0].signatures[0] = hex"1234567890";

    vm.prank(author);
    vm.expectRevert();
    comments.batchOperations{ value: 0 }(operations);
  }

  function test_BatchEditAndDeleteSequence() public {
    // First create a comment outside of batch
    Comments.CreateComment memory commentData = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");
    bytes32 commentId = comments.getCommentId(commentData);
    bytes memory appSignature = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      commentId
    );

    vm.prank(author);
    comments.postComment(commentData, appSignature);

    // Now create batch operations to edit then delete
    Comments.EditComment memory editData = TestUtils.generateDummyEditComment(
      comments,
      author,
      app
    );
    bytes32 editHash = comments.getEditCommentHash(commentId, author, editData);
    bytes memory editSignature = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      editHash
    );

    Comments.BatchOperation[] memory operations = new Comments.BatchOperation[](
      2
    );

    // Edit operation
    operations[0] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.EDIT_COMMENT,
      value: 0,
      data: abi.encode(commentId, editData),
      signatures: new bytes[](1)
    });
    operations[0].signatures[0] = editSignature;

    // Delete operation
    operations[1] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.DELETE_COMMENT,
      value: 0,
      data: abi.encode(commentId),
      signatures: new bytes[](0)
    });

    vm.prank(author);
    comments.batchOperations{ value: 0 }(operations);

    // Verify comment was edited then deleted
    assertTrue(comments.isDeleted(commentId), "Comment should be deleted");
  }

  function test_ReentrancyProtectionInBatch() public {
    // Batch operations should be protected against reentrancy
    Comments.CreateComment memory commentData1 = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");
    Comments.CreateComment memory commentData2 = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");

    commentData1.content = "First batch comment";
    commentData2.content = "Second batch comment";

    bytes32 commentId1 = comments.getCommentId(commentData1);
    bytes32 commentId2 = comments.getCommentId(commentData2);

    bytes memory appSignature1 = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      commentId1
    );
    bytes memory appSignature2 = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      commentId2
    );

    Comments.BatchOperation[] memory operations = new Comments.BatchOperation[](
      2
    );

    operations[0] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT,
      value: 0,
      data: abi.encode(commentData1),
      signatures: new bytes[](1)
    });
    operations[0].signatures[0] = appSignature1;

    operations[1] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT,
      value: 0,
      data: abi.encode(commentData2),
      signatures: new bytes[](1)
    });
    operations[1].signatures[0] = appSignature2;

    vm.prank(author);
    comments.batchOperations{ value: 0 }(operations);

    // Verify both comments were created successfully
    Comments.Comment memory stored1 = comments.getComment(commentId1);
    Comments.Comment memory stored2 = comments.getComment(commentId2);

    assertEq(
      stored1.content,
      "First batch comment",
      "First comment should be created"
    );
    assertEq(
      stored2.content,
      "Second batch comment",
      "Second comment should be created"
    );
  }

  function test_BatchOperationGasLimitAttack() public {
    // Test that individual operations within batch can't consume all gas
    Comments.CreateComment memory commentData = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");

    // Create large metadata array to consume gas
    Metadata.MetadataEntry[]
      memory largeMetadata = new Metadata.MetadataEntry[](100);
    for (uint i = 0; i < 100; i++) {
      largeMetadata[i] = Metadata.MetadataEntry({
        key: keccak256(abi.encodePacked("key", i)),
        value: new bytes(1000) // 1KB per entry
      });
    }
    commentData.metadata = largeMetadata;

    bytes32 commentId = comments.getCommentId(commentData);
    bytes memory appSignature = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      commentId
    );

    Comments.BatchOperation[] memory operations = new Comments.BatchOperation[](
      1
    );
    operations[0] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT,
      value: 0,
      data: abi.encode(commentData),
      signatures: new bytes[](1)
    });
    operations[0].signatures[0] = appSignature;

    vm.prank(author);
    try comments.batchOperations{ value: 0 }(operations) {
      // Should either succeed or fail gracefully
      Comments.Comment memory stored = comments.getComment(commentId);
      assertEq(
        stored.author,
        author,
        "Comment should be created if operation succeeds"
      );
    } catch {
      // Expected to fail due to gas limits
    }
  }

  function test_SignatureReplayInBatch_ShouldFail() public {
    // Test that same signature can't be used in multiple batch operations
    Comments.CreateComment memory commentData = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");
    bytes32 commentId = comments.getCommentId(commentData);
    bytes memory appSignature = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      commentId
    );

    Comments.BatchOperation[] memory operations = new Comments.BatchOperation[](
      2
    );

    // Same operation twice with same signature
    operations[0] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT,
      value: 0,
      data: abi.encode(commentData),
      signatures: new bytes[](1)
    });
    operations[0].signatures[0] = appSignature;

    operations[1] = Comments.BatchOperation({
      operationType: Comments.BatchOperationType.POST_COMMENT,
      value: 0,
      data: abi.encode(commentData),
      signatures: new bytes[](1)
    });
    operations[1].signatures[0] = appSignature; // Same signature

    vm.prank(author);
    vm.expectRevert(); // Should fail on second operation
    comments.batchOperations{ value: 0 }(operations);
  }

  function test_ReplayAttackAfterDelete_ShouldFail() public {
    // Test that signatures can't be replayed even after comment deletion
    Comments.CreateComment memory commentData = TestUtils
      .generateDummyCreateComment(author, app, "Test comment");
    commentData.content = "Original comment";

    bytes32 commentId = comments.getCommentId(commentData);
    bytes memory appSignature = TestUtils.signEIP712(
      vm,
      appPrivateKey,
      commentId
    );

    // Step 1: Post the comment successfully
    vm.prank(author);
    comments.postComment(commentData, appSignature);

    // Verify comment was created
    Comments.Comment memory storedComment = comments.getComment(commentId);
    assertEq(
      storedComment.content,
      "Original comment",
      "Comment should be created"
    );
    assertFalse(
      comments.isDeleted(commentId),
      "Comment should not be deleted initially"
    );

    // Step 2: Delete the comment
    vm.prank(author);
    comments.deleteComment(commentId);

    // Verify comment was deleted
    assertTrue(comments.isDeleted(commentId), "Comment should be deleted");

    // Step 3: Attempt to replay the same comment with the same signature
    // This should fail because the signature has already been used
    vm.prank(author);
    vm.expectRevert(); // Should fail due to signature replay protection
    comments.postComment(commentData, appSignature);
  }

  function onERC721Received(
    address,
    address,
    uint256,
    bytes calldata
  ) external pure returns (bytes4) {
    return IERC721Receiver.onERC721Received.selector;
  }
}
