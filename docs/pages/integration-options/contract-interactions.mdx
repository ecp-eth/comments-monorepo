# Integration Options

## Contract Interaction

In certain situations, such as bot development or custom integrations, you may want to directly interact with the CommentsV1 smart contract.

**Caveat**: Always check if you can achieve the same result by using our [Indexer API](/integration-options#2-indexer-api),
indexer service provides all comment data readily available for consumption, eliminating the need to manually scan the chain.
This significantly improves performance and reduces complexity in your application.

### Contract Addresses

See [COMMENTS_V1_ADDRESS](/sdk-reference/defaultExports/variables/COMMENTS_V1_ADDRESS)

### Post the comment as author

To show how to interact with the contract, we will create a simple example that simulates the author posting the comment and signed by app server.

- The author will post according to the [post comment flow](/post-comment-flow#1-author-pays-gas), and eventually pay for the gas.
- The app server will authorize the post by signing the comment data.

::::steps

#### Install tooling

In this example we will use `@ecp.eth/sdk` and `viem` to interact with the contract:

:::code-group

```bash [npm]
npm install viem "@ecp.eth/sdk"
```

```bash [yarn]
yarn add viem "@ecp.eth/sdk"
```

```bash [pnpm]
pnpm add viem "@ecp.eth/sdk"

```

:::

#### Get access to the blockchain with RPC endpoint

RPC endpoint is the entry point to interact with the blockchain, you can get a free RPC endpoint from [Infura](https://infura.io/), [Alchemy](https://www.alchemy.com/), or [Reown](https://docs.reown.com/advanced/providers/ethereum).

Alternatively, if you don't want to mess with real world assets, you can also use [Anvil](https://book.getfoundry.sh/anvil/) to create a simulated blockchain.
See [Test with Anvil](/test-with-anvil) for more details.

Once you have the RPC endpoint URI, you can create a `transport` for `viem`:

```typescript
const transport = http(rpcEndpointURI);
```

#### Simulate the App Server signing the post

For the app to sign and authorize posting, we will need the following information:

- The author's address
- The target chain for posting the comment
- The comment content
- The target URI of the comment

Let's create a function that signs comments for the app server. Here's the function signature:

```typescript
type sign = (
  authorAddress: Hex,
  chain: Chain,
  content: string,
  targetUri: string
) => Promise<{
  signature: Hex;
  commentData: CommentData;
}>;
```

Now let's get the comment data ready for signing...

Frist create a `CommentData` object with the provided info:

```typescript
const commentData = createCommentData({
  content,
  targetUri,
  // we are posting a top level comment, so no parentId
  parentId: undefined,
  author: authorAddress,
  appSigner: appSigner.address,
});
```

Then create a typed data structure from `commentData` according to EIP-712:

```typescript
const typedCommentData = createCommentTypedData({
  commentData,
  chainId: chain.id,
});
```

Finally, sign the typed data using the app signer's private key and return both `signature` and `commentData`:

```typescript
const signature = await appSigner.signTypedData(typedCommentData);

return {
  signature,
  commentData,
};
```

Now we finished the App Server signing process, let's see how the author posting the comment.

**Note**: Do not expose the app signer's private key in the client side in real scenario, here we simplified the setup and is only for demostration purpose

#### Create wallet client for signing the transaction

To interact with the blockchain and the contract, we will create an `account/signer`,
to create a `wallet client` which allows us to sign and send transaction to the blockchain.

To create an `account`, for simplicity and demostration purpose, we will use a hard coded private key:

```typescript
private readonly authorPrivateKey =
    "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d";
private readonly authorSigner = privateKeyToAccount(this.authorPrivateKey);
```

Please note that in real scenario, you probably want to connect to a user's wallet app, such as MetaMask or Rainbow, to sign and send the transaction.
To see how to do that, please refer to:

1. viem's documentation on [JSON RPC accounts](https://viem.sh/docs/clients/wallet#json-rpc-accounts), and
1. Reown's [Ethereum RPC Provider](https://docs.reown.com/advanced/providers/ethereum)
1. Or use [Rainbowkit](https://www.rainbowkit.com/docs/custom-wallet-list#walletconnect)

Feel free to explore all possible solutions for your case.
However, we will go with what we've got so far: combining `transport` and `account/signer` to create a `viem` wallet client:

```typescript
// Create wallet client for interacting with the contract
private readonly walletClient = createWalletClient({
  chain: anvil,
  transport,
  account: this.authorSigner,
});
```

We will use the wallet client later in the tutorial.

#### Simulate the Author posting the comment

The signature for the function to create on author side is self-explanatory:

```typescript
type postComment(content: string, targetUri: string) => Promise<TransactionReceipt>
```

We will start by sending the comment data to the App Server for signing.

In the real scenario, the client side posts the data to the server via HTTP or whatever transport of your choice,
usually the App Server is deployed by a different party to keep the private key secure.

However, to demonstrate the flow in this example, we'll directly call the `sign` function from the `AppServer` instance.

```typescript
const appSignedComment = await this.appServer.sign(
  authorSigner.address,
  anvil,
  content,
  targetUri
);
```

Then we call the function on the contract to post the comment, and wait for the transaction to be mined:

```typescript
const tx = await commentsContract.write.postCommentAsAuthor(
  [appSignedComment.commentData, appSignedComment.signature],
  {
    account: walletClient.account,
  }
);

const receipt = await waitForTransactionReceipt(walletClient, {
  hash: tx,
});

return receipt;
```

#### Put everything together

Here is the complete example, with everything put together:

```typescript
import { http, createWalletClient, getContract, Hex, Chain } from "viem";
import { anvil } from "viem/chains";
import { waitForTransactionReceipt } from "viem/actions";
import {
  COMMENTS_V1_ADDRESS,
  createCommentData,
  createCommentTypedData,
} from "@ecp.eth/sdk";
import { CommentsV1Abi } from "@ecp.eth/sdk/abis";
import { privateKeyToAccount } from "viem/accounts";

// we use a local anvil node for this example,
// anvil is a local ethereum node that is used for testing and development.
// run `pnpm i && pnpm run dev` in `/packages/protocol/` to start the node,
// the script will also deploy the contract to the node
const transport = http("http://localhost:8545");

/**
 * The class simulate the app server that signs the comment.
 * In real scenario, the client side post the data to the server,
 * and the app signing process should be hide away from the client.
 */
class AppServer {
  private readonly appSignerPrivateKey =
    "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
  private readonly appSigner = privateKeyToAccount(this.appSignerPrivateKey);

  /**
   * Sign the comment data as the app server
   * @param authorAddress - The address of the author of the comment
   * @param chain - The chain on which the comment is being posted
   * @param content - The content of the comment
   * @param targetUri - The URI of the target of the comment
   * @returns The signed comment data
   */
  async sign(
    authorAddress: Hex,
    chain: Chain,
    content: string,
    targetUri: string
  ) {
    const appSigner = this.appSigner;

    // create comment data
    const commentData = createCommentData({
      content,
      targetUri,
      // we are posting a top level comment, so no parentId
      parentId: undefined,
      author: authorAddress,
      appSigner: appSigner.address,
    });

    // create a typed data according to EIP-712 for signing
    const typedCommentData = createCommentTypedData({
      commentData,
      chainId: chain.id,
    });

    const signature = await appSigner.signTypedData(typedCommentData);
    // const hash = hashTypedData(typedCommentData);

    return {
      signature,
      // hash,
      commentData,
    };
  }
}

/**
 * The class simulate the author who posts the comment from client side
 */
class Author {
  private readonly authorPrivateKey =
    "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d";
  private readonly authorSigner = privateKeyToAccount(this.authorPrivateKey);
  // Create wallet client for interacting with the contract
  private readonly walletClient = createWalletClient({
    chain: anvil,
    transport,
    account: this.authorSigner,
  });
  // Get contract instance
  private readonly commentsContract = getContract({
    address: COMMENTS_V1_ADDRESS,
    abi: CommentsV1Abi,
    client: this.walletClient,
  });

  constructor(private appServer: AppServer) {}

  async postComment(content: string, targetUri: string) {
    const authorSigner = this.authorSigner;
    const walletClient = this.walletClient;
    const commentsContract = this.commentsContract;

    // to begin with, we post the comment data over to app server,
    // to get the app server signed comment data
    const appSignedComment = await this.appServer.sign(
      authorSigner.address,
      anvil,
      content,
      targetUri
    );

    // post comment data and app signature so the contract can verify the comment is authorized by the app
    const tx = await commentsContract.write.postCommentAsAuthor(
      [appSignedComment.commentData, appSignedComment.signature],
      {
        // postCommentAsAuthor transaction will be executed by author signer so the author will have to pay.
        account: walletClient.account,
      }
    );

    const receipt = await waitForTransactionReceipt(walletClient, {
      hash: tx,
    });

    return receipt;
  }
}

(async () => {
  const author = new Author(new AppServer());
  console.log("author is posting the comment and paying for the gas...");
  const receipt = await author.postComment(
    "Somebody successfully finished the tutorial!",
    "https://demo.ethcomments.xyz"
  );
  console.log(
    "author has posted the comment and the transaction is mined, transaction hash: ",
    receipt.transactionHash
  );
})();
```

See [Protocol API Reference](/protocol-reference/CommentsV1) for more functions and details.

#### Congratulations! You've completed the tutorial!

::::

#### Next Steps

- Check out **gasless** [post comment flows](/post-comment-flow)

### Best Practices

1. Set reasonable deadlines (e.g., 1 hour from current time)
1. Implement proper error handling
1. Monitor gas costs and adjust gas limits accordingly
1. Consider implementing retry mechanisms for failed transactions
1. Keep private keys secure and never expose them in client-side code
1. While the contract doesn't impose rate limits, consider implementing application-level rate limiting to prevent spam and manage gas costs effectively.
1. Consider anti-spam measures
