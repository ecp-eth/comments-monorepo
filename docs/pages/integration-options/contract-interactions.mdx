# Integration Options

## Contract Interaction

### 1. Post the comment as the author

In this section, we will walkthrough the code from the [demo app](https://github.com/ecp-eth/comments-monorepo/tree/main/apps/demo) to illustrate the process of posting a comment as the author.

The ECP supports 4 types of comment posting flows, each with its pros and cons.

Here we will discuss [the simplest flow](/post-comment-flows#1-author-pays-gas):

- The author posts and pays for gas, see ["author pays for the gas"](/post-comment-flows#1-author-pays-gas).
- The app server authorizes the post by signing the comment data.

You may want to read more about the [post comment flows](/post-comment-flows) for more details.

#### The Contract

- For latest contract address, see [COMMENTS_V1_ADDRESS](/sdk-reference/defaultExports/variables/COMMENTS_V1_ADDRESS).
- We will call [`postCommentAsAuthor()`](/protocol-reference/CommentsV1#postcommentasauthorstruct-commentsv1commentdata-commentdata-bytes-appsignature-external) method to post the comment.

#### Demo Dependencies

Here is a quick rundown of some of the dependencies used in the demo app:

1. `@ecp.eth/sdk` - for comment data creation, retrieving, and interaction with the indexer.
1. `wagmi` - for react based wallet connection
1. `viem` - for contract interaction
1. `@rainbow-me/rainbowkit` - for wallet connection UI
1. `@tanstack/react-query` - for data fetching and caching

#### Test environment

- We use [Anvil](https://book.getfoundry.sh/anvil/) for local testing and development, follow the steps in [Test with Anvil](/test-with-anvil) to set up the environment.
- You may want to set up an indexer locally as well, see [Indexer](/indexer-reference/) for more details.

Now let's go through the steps to post a comment!

::::steps

##### Collect the comment data and send it to the server for signing

We will start by collecting the [comment data](/comment-data-props) and send it to the server for signing:

The comment data is sent to the server for signing:

```typescript
const response = await fetch("/api/sign-comment", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    content,
    targetUri: window.location.href,
    parentId,
    author: address,
    chainId,
  }),
});
```

üßë‚Äçüíª _[/apps/demo/src/components/comments/CommentBox.tsx#L62](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/src/components/comments/CommentBox.tsx#L62)_

##### The App Server signs the comment data

Once the data reaches the app server, it creates a `CommentData` object using `createCommentData` from `@ecp.eth/sdk`:

```typescript
const commentData = createCommentData({
  content,
  targetUri,
  // we are posting a top level comment, so no parentId
  parentId: undefined,
  author: authorAddress,
  appSigner: appSigner.address,
});
```

[`createCommentData()`](/sdk-reference/defaultExports/functions/createCommentData) also accepts 2 extra options which are worth mentioning:

- `deadline` - you want to avoid setting a `deadline` that is too long to expire, deadline plays an important role here in preventing a replay attacks. The longer expiry of `deadline` increases the security risk.
- `salt` - a random value to make each comment unique, its uniqueness is essential for generating comment hash which is also used as `commentId`.

Create a typed data structure from `commentData` according to EIP-712:

```typescript
const typedCommentData = createCommentTypedData({
  commentData,
  chainId: chain.id,
});
```

Finally, sign the typed data using the app signer's private key and return both `signature` and `commentData`:

```typescript
const signature = await appSigner.signTypedData(typedCommentData);

return {
  signature,
  commentData,
};
```

üßë‚Äçüíª _[/apps/demo/src/app/api/sign-comment/route.ts#L48-L61](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/src/app/api/sign-comment/route.ts#L48-L61)_

**Note**:

- Do not expose the app signer's private key on the client side.
  In the demo, we store the private key in the environment variable `APP_SIGNER_PRIVATE_KEY`.
  Next.JS ensures that the environment variable without `NEXT_PUBLIC_` prefix is only available on the server side.

Now that we have finished server-side signing, let's move on to the client side.

#### The Author signs and sends the transaction

In the demo, we use a combination of `wagmi` and `rainbowkit` to connect the user wallet and send the transaction to the contract.
You can find out how it was set up in the `providers` component:

```tsx
<QueryClientProvider client={queryClient}>
  <WagmiProvider config={config}>
    <RainbowKitProvider>{children}</RainbowKitProvider>
  </WagmiProvider>
</QueryClientProvider>
```

üßë‚Äçüíª _[/apps/demo/src/app/providers.tsx#L16-L20](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/src/app/providers.tsx#L16-L20)_

Now with the wagmi ready to go, and the comment data and app signature returned from the server, we can now post the comment to the contract:

```typescript
await writeContractAsync({
  abi: CommentsV1Abi,
  address: COMMENTS_V1_ADDRESS,
  functionName: "postCommentAsAuthor",
  args: [commentData, appSignature],
});
```

üßë‚Äçüíª _[/apps/demo/src/lib/contract.ts#L40-L45](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/src/lib/contract.ts#L40-L45)_

##### Congratulations! You've completed the tutorial!

::::

### 2. Post comment in any Ethereum transaction

Sometimes, you might want to attach a comment directly to a transaction -- without the need for an additional transaction or smart contract integration. This can be useful for:

- Reducing gas costs by embedding the comment in the transaction calldata
- Adding notes to NFT mints
- Commenting on token transfers
- Providing context for any smart contract interaction

In this document, we will walkthrough the code from the [demo app](https://github.com/ecp-eth/comments-monorepo/tree/main/apps/demo)
to illustrate the process of posting a comment as part of any transaction.

#### The Contract

- For latest contract address, see [COMMENTS_V1_ADDRESS](/sdk-reference/defaultExports/variables/COMMENTS_V1_ADDRESS).

#### How it works

The demo app uses a test contract with the method `yoink()` to illustrate how to include a comment in a transaction.
For a detailed explanation of the flow, see the [Post Comment Flows](/post-comment-flows#4-appending-comment-to-a-transaction-author-pays-gas).

1. The author creates a signed comment data by sending it to the app server for signing.
1. The author encodes the signed comment data into a hex string.
1. The author calls the `yoink()` method on the contract and passes the encoded comment data as calldata suffix.
1. Once the transaction is broadcasted, the comment in calldata will then be indexed by our ponder indexer.

For dependencies and test environment setup, please refer to previous [examples in this section](/integration-options/contract-interactions).

##### Test contract

The test contract source code is available in the [test-protocol package](https://github.com/ecp-eth/comments-monorepo/tree/main/packages/test-protocol).

Should you want to deploy your test contract, follow the steps in the [README file](https://github.com/ecp-eth/comments-monorepo/blob/main/packages/test-protocol/README.md),
then update the address used for the demo app in the `.env` files:

```
NEXT_PUBLIC_YOINK_CONTRACT_ADDRESS=
```

üßë‚Äçüíª _[/apps/demo/.env.example#L62](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/.env.example#L43)_

Read more about testing with a local anvil node in [Test with Anvil](/test-with-anvil).

**FYI:** If you are testing the comment posting integration, contract deployment is not strictly required:

When no contract is deployed at the target address, the transaction that invokes the function will still succeed, but no code will be executed.
The indexer will still capture the successful transaction as long as it contains the [ECP delimiter](/sdk-reference/defaultExports/variables/COMMENT_CALLDATA_SUFFIX_DELIMITER) in the calldata.

Now let's get started with the code!

::::steps

##### Get the comment data signed by the app server

As all previous examples, the author will start by collecting the required
[comment data](/comment-data-props) and send it to the app server for signing:

```typescript
const response = await fetch("/api/sign-comment", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    content,
    targetUri: window.location.href,
    parentId,
    author: address,
    chainId,
  }),
});
```

üßë‚Äçüíª _[/apps/demo/src/components/comments/CommentBox.tsx#L62](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/src/components/comments/CommentBox.tsx#L62)_

##### Encode the comment data

Next, we want to encode signed comment data into hex using `encodeAbiParameters` with the ABI definition of the comment data,
luckily we have a helper function `createCommentSuffixData` from the SDKto do just that:

```typescript
const commentDataSuffix = createCommentSuffixData({
  commentData,
  appSignature,
});
```

üßë‚Äçüíª _[/apps/demo/src/lib/contract.ts#L21-L24](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/src/lib/contract.ts#L21-L24)_

##### Include a comment in your transaction

Now you can create the test contract instance and include the encoded comment data in your transaction's data field:

```typescript
return await writeContractAsync({
  address:
    publicEnv.NEXT_PUBLIC_YOINK_CONTRACT_ADDRESS ??
    never("Yoink contract address is not set"),
  abi: parseAbi(["function yoink()"]),
  functionName: "yoink",
  args: [],
  dataSuffix: commentDataSuffix,
});
```

üßë‚Äçüíª _[/apps/demo/src/lib/contract.ts#L26-L33](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/src/lib/contract.ts#L26-L33)_

and wait for the transaction to be mined:

```typescript
const { data: receipt, isLoading: isReceiptLoading } =
  useWaitForTransactionReceipt({
    hash: submitMutation.data?.txHash,
  });
```

üßë‚Äçüíª _[/apps/demo/src/components/comments/CommentBox.tsx#L113-L116](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/src/components/comments/CommentBox.tsx#L113-L116)_

The comments indexer will scan transactions for valid comment data and index any comments it finds, making them available through the indexer API.

##### Testing the integration

You can verify your integration by:

1. Checking the indexer API (or [deploy indexer locally](/indexer-reference)) to see if the comment was indexed
1. Viewing the comment on your app's UI

##### Congrats! You've completed the tutorial!

::::

### Best Practices

1. Implement proper error handling
1. Monitor gas costs and adjust gas limits accordingly
1. Consider implementing retry mechanisms for failed transactions
1. Keep private keys secure and never expose them in client-side code
1. While the contract doesn't impose rate limits, consider implementing application-level rate limiting to prevent spam and manage gas costs effectively.
1. Consider anti-spam measures

### Additional Resources

- Check out **gasless** [post comment flows](/post-comment-flows)
- See [Protocol API Reference](/protocol-reference/CommentsV1) for more functions and details.
- See [Demo App Source Code](https://github.com/ecp-eth/comments-monorepo/tree/main/apps/demo) for implementations of:
  1. The other post comment flows.
  2. Request permission from the user for gasless posting.
  3. Deleting comments.
