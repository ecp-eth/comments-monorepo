# Integration Options

## Contract Interaction

In certain situations, such as bot development or custom integrations, you may want to directly interact with the CommentsV1 smart contract.

### Contract and the methods used in this document

- For latest contract address, see [COMMENTS_V1_ADDRESS](/sdk-reference/defaultExports/variables/COMMENTS_V1_ADDRESS).
- We will call [`postCommentAsAuthor`](/protocol-reference/CommentsV1#postcommentasauthorstruct-commentsv1commentdata-commentdata-bytes-appsignature-external) method to post the comment.

### Post the comment as author

In this document we will walkthrough the code from the [demo app](https://github.com/ecp-eth/comments-monorepo/tree/main/apps/demo) to illustrate the process of posting a comment as the author.

The ECP supports 4 types of comment posting flows, each with their own pros and cons.

Here we will discuss [the simplest flow](/post-comment-flows#1-author-pays-gas):

- The author posts and pays for gas, see ["author pays for the gas"](/post-comment-flows#1-author-pays-gas).
- The app server authorises the post by signing the comment data.

You may want to read more about the [post comment flows](/post-comment-flows) for more details.

### Demo Dependencies

Here is a quick run down of some of the dependencies used in the demo app:

1. `@ecp.eth/sdk` - for comment data creation, retrieving and interaction with the indexer.
1. `wagmi` - for react based wallet connection
1. `viem` - for contract interaction
1. `@rainbow-me/rainbowkit` - for wallet connection UI
1. `@tanstack/react-query` - for data fetching and caching

### Test environment

- We use [Anvil](https://book.getfoundry.sh/anvil/) for local testing and development, follow the steps in [Test with Anvil](/test-with-anvil) to setup the environment.
- You may want to setup indexer locally as well, see [Indexer](/indexer-reference/) for more details.

Now let's go through the steps to post a comment!

::::steps

#### Collect the comment data and send it to server for signing

We will start by collecting the [comment data](/comment-data-props) and send it to the server for signing:

The comment data is sent to the server for signing:

```typescript
const response = await fetch("/api/sign-comment", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    content,
    targetUri: window.location.href,
    parentId,
    author: address,
    chainId,
  }),
});
```

üßë‚Äçüíª _[/apps/demo/src/components/comments/CommentBox.tsx#L62](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/src/components/comments/CommentBox.tsx#L62)_

#### App Server signs the comment data

Once the data reaches the app server, it creates a `CommentData` object using `createCommentData` from `@ecp.eth/sdk`:

```typescript
const commentData = createCommentData({
  content,
  targetUri,
  // we are posting a top level comment, so no parentId
  parentId: undefined,
  author: authorAddress,
  appSigner: appSigner.address,
});
```

[`createCommentData()`](/sdk-reference/defaultExports/functions/createCommentData) also accepts 2 extra options which are worth mentioning:

- `deadline` - you want to avoid setting a `deadline` that is too long to expire, deadline plays a important role here for preventing replay attack. Longer expiry of `deadline` increases the security risk.
- `salt` - a random value to make each comment unique, its uniqueness is essential for generating comment hash which is also used as `commentId`.

Create a typed data structure from `commentData` according to EIP-712:

```typescript
const typedCommentData = createCommentTypedData({
  commentData,
  chainId: chain.id,
});
```

Finally, sign the typed data using the app signer's private key and return both `signature` and `commentData`:

```typescript
const signature = await appSigner.signTypedData(typedCommentData);

return {
  signature,
  commentData,
};
```

üßë‚Äçüíª _[/apps/demo/src/app/api/sign-comment/route.ts#L48-L61](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/src/app/api/sign-comment/route.ts#L48-L61)_

**Note**:

- Do not expose the app signer's private key in the client side.
  In the demo we store the private key in environment variable `APP_SIGNER_PRIVATE_KEY`.
  Next.JS ensures that the environment variable without `NEXT_PUBLIC_` prefix is only available on the server side.

Now that we have finished server side signing, let's move on to the client side.

#### The Author signs and sends the transaction

In the demo, we use a combination of `wagmi` and `rainbowkit` to connect the user wallet and send the transaction to the contract.
You can find out how it was setup in the `providers` component:

```tsx
<QueryClientProvider client={queryClient}>
  <WagmiProvider config={config}>
    <RainbowKitProvider>{children}</RainbowKitProvider>
  </WagmiProvider>
</QueryClientProvider>
```

üßë‚Äçüíª _[/apps/demo/src/app/providers.tsx#L16-L20](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/src/app/providers.tsx#L16-L20)_

Now with the wagmi ready to go, and the comment data and app signature returned from the server, we can now post the comment to the contract:

```typescript
await writeContractAsync({
  abi: CommentsV1Abi,
  address: COMMENTS_V1_ADDRESS,
  functionName: "postCommentAsAuthor",
  args: [commentData, appSignature],
});
```

üßë‚Äçüíª _[/apps/demo/src/lib/contract.ts#L40-L45](https://github.com/ecp-eth/comments-monorepo/blob/094bcde2bca079bd7451c6571f26c5687b2ad128/apps/demo/src/lib/contract.ts#L40-L45)_

#### Congratulations! You've completed the tutorial!

::::

### Best Practices

1. Implement proper error handling
1. Monitor gas costs and adjust gas limits accordingly
1. Consider implementing retry mechanisms for failed transactions
1. Keep private keys secure and never expose them in client-side code
1. While the contract doesn't impose rate limits, consider implementing application-level rate limiting to prevent spam and manage gas costs effectively.
1. Consider anti-spam measures

#### Next Steps

- Check out **gasless** [post comment flows](/post-comment-flows)
- See [Protocol API Reference](/protocol-reference/CommentsV1) for more functions and details.
- See [Demo App Source Code](https://github.com/ecp-eth/comments-monorepo/tree/main/apps/demo) for implementations of:
  1. The other post comment flows.
  2. Request permission from the user for gasless posting.
  3. Deleting comments.
