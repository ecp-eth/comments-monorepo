# Comment

The `Comment` is a data structure that contains the essential information of a comment.

## `content`

The comment content stores the plain text content of the comment.

- Please use `\n` for line breaks. (Most browsers will normalize the line breaks to `\n` regardless of the OS).
- any media or links that should be displayed to users should be stored in the content property and rendered by clients based on the media type at the uri.
- For **reactions** (commentType = 1), the content field contains the reaction type as a string.

### Reaction Content Types

When `commentType = 1` (reaction), the `content` field should contain a string indicating the type of reaction:

#### Standardized Reaction Types

- `"like"` - General approval or appreciation
- `"downvote"` - Disagreement or negative feedback
- `"repost"` - Sharing or amplifying the content

#### Custom Reaction Types

Applications can define their own reaction types based on their specific use cases:

- `"heart"` - Love or strong appreciation
- `"laugh"` - Humorous response
- `"angry"` - Strong disagreement
- `"celebrate"` - Excitement or congratulations
- `"insightful"` - Marking content as particularly valuable

#### Implementation Notes

- Reaction content should be a simple string identifier (lowercase recommended)
- Applications should validate reaction types against their supported list
- Unknown reaction types should be handled gracefully by displaying a generic reaction icon
- Consider internationalization when displaying reaction labels to users

## `metadata`

The `metadata` property stores additional data as key-value pairs that shouldn't be shown to the user as-is.

- Stored as an array of `MetadataEntry` structures with `bytes32 key` and `bytes value` fields
- Keys should be UTF-8 encoded strings with format "key type" (e.g., "category string", "priority uint256")
- Values are stored as `bytes` and can contain any encoded data type
- Significantly more gas-efficient than JSON strings, especially when metadata is empty
- Please be mindful that storing large amounts of data on the chain will increase the cost of the transaction.

### Metadata Access

```solidity
// Get all metadata for a comment
Comments.MetadataEntry[] memory metadata = commentManager.getCommentMetadata(commentId);

// Get specific metadata value
bytes memory value = commentManager.getCommentMetadataValue(commentId, keccak256("category string"));

// Get all metadata keys
bytes32[] memory keys = commentManager.getCommentMetadataKeys(commentId);
```

## `targetUri`

It serves as a unique identifier for locating comments.

Be careful when choosing the value for the `targetUri` property as an inconsistent `targetUri` will result in some comments missing from the indexer response.

- Any URIs, as long as it is a unique string that follows the [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) standard.
- If your web page is dynamic and accepts query parameters, you should carefully consider which parameters are necessary to locate the correct comments. As a general rule:

  1. Normalize the URL, e.g. using [`normalize-url`](https://www.npmjs.com/package/normalize-url).
  1. Sort the query parameters using `sortQueryParameters` from [`normalize-url`](https://www.npmjs.com/package/normalize-url).
  1. Do not include query parameters unrelated to page content, such as tracking or feature flags.

- If the comment is a reply to a comment then set the value to `undefined`.

### App/Chain Agnostic URIs

Whenver possible, it is recommended to use app or chain agnostic URIs, e.g. [CAIP-19](https://github.com/ChainAgnostic/namespaces/blob/main/eip155/caip19.md) specification for referencing onchain or offchain assets.
This ensures the reference is consistent and maximal compatibility across different applications and chains.

Example (NFT and collection):

```
chain://eip155:1/erc721:0xa723a8a69d9b8cf0bc93b92f9cb41532c1a27f8f/11
chain://eip155:1/erc721:0xa723a8a69d9b8cf0bc93b92f9cb41532c1a27f8f
```

## `parentId`

The `parentId` property is used to store the parent comment id.

- If the comment is a reply to a comment, set the `parentId` to the id of the parent comment.
- If the comment is a top-level comment, leave it `undefined`.

## `author`

The `author` property is used to store the author's address. It is the address of the account that created and owns the comment.

## `app`

The `app` property is used to store the app signer's address. The app signer represents the the owner of the app or community.
If you are creating features just for yourself to post, such as a blog, you can use your own address as the `app`.

To see detailed explanation please refer to the [Dual-signature System](./dual-signature-system.mdx) page.

## `deadline`

The deadline is a timestamp in seconds since the epoch. Posting a comment with an expired deadline will result in the transaction being reverted.

- It must be a future timestamp.
- It provides a guarantee around the timestamp when the user or app countersigned the comment.

## `commentType`

The `commentType` property uses a `uint8` value to efficiently categorize different types of comments.

### Comment Type Values

| Value | Name                  | Description                | Usage                                       |
| ----- | --------------------- | -------------------------- | ------------------------------------------- |
| `0`   | **Comment** (Default) | Standard text comments     | Regular discussions, replies, conversations |
| `1`   | **Reaction**          | Quick reactions to content | Likes, dislikes, hearts, thumbs up/down     |

### Constants

The `Comments` library provides constants for easy reference:

```solidity
Comments.COMMENT_TYPE_COMMENT = 0;   // Standard comment
Comments.COMMENT_TYPE_REACTION = 1;  // Reaction
```

### Usage Examples

#### Standard Comment (Type 0)

```solidity
Comments.CreateComment memory commentData = Comments.CreateComment({
    author: userAddress,
    app: appAddress,
    channelId: 1,
    deadline: block.timestamp + 3600,
    parentId: bytes32(0),
    commentType: 0, // or Comments.COMMENT_TYPE_COMMENT
    content: "This is a thoughtful response to the discussion.",
    metadata: new Comments.MetadataEntry[](0),
    targetUri: "https://example.com/post/123"
});
```

#### Reaction (Type 1)

```solidity
Comments.CreateComment memory reactionData = Comments.CreateComment({
    author: userAddress,
    app: appAddress,
    channelId: 1,
    deadline: block.timestamp + 3600,
    parentId: bytes32(0),
    commentType: 1, // or Comments.COMMENT_TYPE_REACTION
    content: "like", // The reaction type goes in the content field
    metadata: new Comments.MetadataEntry[](0),
    targetUri: "https://example.com/post/123"
});
```

### Implementation Notes

- **Default Behavior**: If `commentType` is not explicitly set, it defaults to `0` (standard comment)
- **Storage Efficiency**: Using `uint8` instead of `string` saves significant gas, especially for reactions
- **Immutable**: Comment type cannot be changed after creation (not included in `EditComment` struct)
- **Validation**: Applications should validate that reaction content contains valid reaction types
- **Extensibility**: Additional comment types can be added in future versions

### Gas Savings

By using `uint8` instead of `string` for comment types:

- **Reactions**: Save ~20,000+ gas per reaction (no string storage needed)
- **Comments**: Save ~10,000+ gas per comment vs storing "comment" string
- **Events**: More efficient event indexing and filtering

### Frontend Integration

Applications can easily filter and display different comment types:

```typescript
// Filter for reactions only
const reactions = comments.filter((c) => c.commentType === 1);

// Filter for standard comments only
const textComments = comments.filter((c) => c.commentType === 0);

// Handle reaction display
if (comment.commentType === 1) {
  displayReaction(comment.content); // "like", "heart", etc.
} else {
  displayComment(comment.content);
}
```

## `channelId`

The `channelId` property is used to organize comments into different channels or categories.

- Must be a numeric identifier (`uint256`).
- Allows applications to segment comments into different groups, communities, or topics.
- Comments with the same `channelId` are logically grouped together.
- Applications can use this to implement features like multiple comment sections, communities, or discussion boards.

## `createdAt` (automatic)

- Timestamp when the comment was first created (in seconds since epoch).
- Set automatically when the comment is posted to the blockchain.
- Cannot be modified after creation.

## `updatedAt` (automatic)

- Timestamp when the comment was last modified (in seconds since epoch).
- Updated automatically whenever the comment content or metadata is edited.
- Initially equals `createdAt` for new comments.

## Hook Metadata

Hook metadata is additional data that can be added by hooks during comment processing, stored separately from regular metadata.

- Stored as key-value pairs similar to regular metadata
- Used by the protocol's hook system to attach additional information to comments
- The specific format and content depend on the hooks implemented by the application
- Applications can use this for custom features like moderation flags, additional metadata, or integration data

### Hook Metadata Access

```solidity
// Get all hook metadata for a comment
Comments.MetadataEntry[] memory hookMetadata = commentManager.getCommentHookMetadata(commentId);

// Get specific hook metadata value
bytes memory value = commentManager.getCommentHookMetadataValue(commentId, keccak256("moderationStatus string"));

// Get all hook metadata keys
bytes32[] memory keys = commentManager.getCommentHookMetadataKeys(commentId);
```
