# Integration Options

## 1. React Component Library

- Pre-built UI components
- Quick integration
- Customizable styling

```tsx
import { CommentsEmbed } from '@ecp.eth/sdk/react'

const baseOrigin = 'https://blog.example.com'

export function Comments() {
  return (
    <div>
      <h3>Comments</h3>
      <CommentsEmbed
        // the uri for commenting
        uri={new URL(
          window.location.pathname,
          baseOrigin
        ).toString()}
      />
    </div>`
  )
}
```

Be careful when choosing the value for the `uri` property. The `uri` serves as a unique identifier to locate comments:

1. If your web page is dynamic and accepts query parameters, you should carefully consider which parameters are necessary to locate the correct comments
and include them in the `uri` property. As a general rule, include query parameters that affect the page content.
2. If you are rendering the `CommentsEmbed` with server-side rendering (SSR), you do not have access to the `window` object.

The `uri` must be a unique string that follows the [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) standard.

## 2. Contract Interaction

This guide explains how to directly interact with the CommentsV1 smart contract for custom integrations or bot development.

### Contract Addresses

See [COMMENTS_V1_ADDRESS](/sdk-reference/default/variables/COMMENTS_V1_ADDRESS)

### Setup

First, install the required dependencies:

```bash
npm install ethers
# or
pnpm add ethers
```

### Basic Setup Code

```typescript
import { ethers } from 'ethers';
import { CommentsV1Abi } from '@ecp.eth/protocol/abi';

// Connect to the network
const provider = new ethers.JsonRpcProvider('YOUR_RPC_URL');
const signer = new ethers.Wallet('YOUR_PRIVATE_KEY', provider);

// Initialize contract
const contractAddress = '0xfed9b3a3884940d0c8a91b55f5e631b33a84f669'; // Base mainnet
const contract = new ethers.Contract(contractAddress, CommentsV1Abi, signer);
```

### Best Practices

1. Always use fresh nonces by querying them before each operation
2. Set reasonable deadlines (e.g., 1 hour from current time)
3. Implement proper error handling
4. Monitor gas costs and adjust gas limits accordingly
5. Consider implementing retry mechanisms for failed transactions
6. Keep private keys secure and never expose them in client-side code
7. While the contract doesn't impose rate limits, consider implementing application-level rate limiting to prevent spam and manage gas costs effectively.
8. Considering anti-spam measures
