# Integration Options

## 1. React Component Library

The React component library provides pre-built, customizable UI components for seamless integration into your React applications.
This is the recommended approach for most web applications.

```tsx
import { CommentsEmbed } from '@ecp.eth/sdk/react'

const baseOrigin = 'https://blog.example.com'

export function Comments() {
  return (
    <div>
      <h3>Comments</h3>
      <CommentsEmbed
        // the uri for commenting
        uri={new URL(
          window.location.pathname,
          baseOrigin
        ).toString()}
        // the config object allows you to customize the CommentsEmbed's appearance
        config={{
          theme: {
            // mode controls which theme to use, it can be 'light' or 'dark'
            mode: 'light',
            colors: {
              dark: {
                background: 'black',
                foreground: '#e9e9ea',
              },
              light: {
                background: 'white',
                foreground: '#4c4c4c',
              },
            },
          },
        }}
      />
    </div>`
  )
}
```

Be careful when choosing the value for the `uri` property. The `uri` serves as a unique identifier to locate comments:

1. If your web page is dynamic and accepts query parameters, you should carefully consider which parameters are necessary to locate the correct comments
and include them in the `uri` property. As a general rule:
    1. include query parameters that affect the page content.
    2. arrange them in alphabetical order.
2. If you are rendering the `CommentsEmbed` with server-side rendering (SSR), you do not have access to the `window` object.

The `uri` must be a unique string that follows the [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) standard.

#### API reference

- [`CommentsEmbed`](/sdk-reference/react/functions/CommentsEmbed)
- [`CommentsEmbedProps`](/sdk-reference/react/type-aliases/CommentsEmbedProps)
- [`EmbedConfigSchemaType`](/sdk-reference/schemas/type-aliases/EmbedConfigSchemaType) - detailed customization options

## 2. Indexer API

The indexer is a service that indexes comments from the CommentsV1 smart contract, and provides a REST API for consumption.

There are different approaches you can access the indexer data:

### SDK functions

You can use functions from `@ecp.eth/sdk` to make accessing the indexer data easier. 
Here are a few examples:

#### Fetch comments

```ts
import { fetchComments } from '@ecp.eth/sdk'

async function main() {
  console.log('fetching comments...')

  const comments = await fetchComments({
    // the url of indexer api
    apiUrl: "https://api.ethcomments.xyz",
    // the uri of commeting target
    targetUri: "https://demo.ethcomments.xyz",
  });

  console.log(
    "here is a list of comments for https://demo.ethcomments.xyz",
    comments
  );
}

main()
```

The response is a list of comments and pagination information:

```json
{
  results: [
    {
      author: {
        "address": "0x8d25687829d6b85d9e0020b8c89e3ca24de20a89",
        "ens": {
          "name": "stephancill.eth",
          "avatarUrl": "https://euc.li/stephancill.eth"
        },
        "farcaster": {
          "fid": 1689,
          "pfpUrl": "https://images.colorino.site/19c754968a5a0d6e5b554a3aa8107d5fe973a88550080f7b1713e3c33989ffa0.png",
          "displayName": "Stephan",
          "username": "stephancill"
        }
      },
      appSigner: "0xe86a6df8ead873600050fb669e7bc8d3b8587f3d",
      chainId: 8453,
      content: "hello world",
      deletedAt: null,
      id: "0xdce24de208a5e15b6b9b7e7c1ccdc5c08d8a7d8ab20c37c60e1d96a2aa1f9941",
      logIndex: 369,
      metadata: "",
      parentId: null,
      targetUri: "https://demo.ethcomments.xyz",
      txHash: "0x0894eea21a4256a2eeba425fd003afd954d7407d34f99aa4f6462df8de87f111",
      timestamp: "2025-02-12T10:47:03.000Z",
      replies: [Object]
    }
  ],
  pagination: { limit: 50, offset: 0, hasMore: false }
}
```

##### API reference

- [`fetchComments`](/sdk-reference/defaultExports/functions/fetchComments)
- [`FetchCommentsOptions`](/sdk-reference/defaultExports/type-aliases/FetchCommentsOptions)

#### Fetch replies

```ts
import { fetchCommentReplies } from '@ecp.eth/sdk'

async function main() {
  console.log('fetching replies...')

  // fetch replies for a comment based on its id
  const replies = await fetchCommentReplies({
    // the url of embed api
    apiUrl: "https://embed.ethcomments.xyz",
    commentId: "0xdce24de208a5e15b6b9b7e7c1ccdc5c08d8a7d8ab20c37c60e1d96a2aa1f9941"
  });

  console.log(
    "here is a list of replies",
    replies
  );
}

main()
```

##### API reference

- [`fetchCommentReplies`](/sdk-reference/defaultExports/functions/fetchCommentReplies)
- [`FetchCommentRepliesOptions`](/sdk-reference/defaultExports/type-aliases/FetchCommentRepliesOptions)


### Rest API

The Rest API is available at `https://api.ethcomments.xyz/**/*`.

TODO: We are currently working on a better way to document REST API.

### Direct GraphQL access

The GraphQL API is available at `https://api.ethcomments.xyz/graphql`.

You can query the data using [your favorite GraphQL client](https://github.com/chentsulin/awesome-graphql), 
or simply visit the GraphQL playground at https://api.ethcomments.xyz/ to try it out.

#### Example queries

Query a comment by its ID:
```graphql
query {
  comment (id: "0xc4f012eaaa9285b0ffa7df432a7eb8f17145c34cfd50de688273b2b7df6bef08") {
    content
  }
}
```

Filter comments by `targetUri` and limit the number of results:
```graphql
query {
  comments(where: { targetUri: "https://demo.ethcomments.xyz" }, limit: 10) {
    # pagination info        
    pageInfo {
      startCursor,
      endCursor,
      hasNextPage
      hasPreviousPage
    }

    # comment details
    items {
      id
      content
    }

    # total number of comments filtered by targetUri
    totalCount
  }
}
```

### Direct database access via ponder client

Ponder access is available at `https://api.ethcomments.xyz/sql`, it allows you to query the indexer database directly.

You can use direct database access for quick investigations and debugging, but this approach is not recommended for production use since the database schema may change without notice. Changes to the schema could break your queries and affect application stability.

#### Install `ponder` and `@ponder/client`

:::code-group

```bash [npm]
npm install ponder @ponder/client
```

```bash [yarn]
yarn add ponder @ponder/client
```

```bash [pnpm]
pnpm add ponder @ponder/client

```

:::

`ponder` package is required by the schema file.

#### Get a copy of the database schema

We are currently working on determining the best way to distribute the database schema. In the meantime, you can obtain it by cloning our repository:

```bash
git clone https://github.com/ecp-eth/comments-monorepo.git
```

The schema is located at `comments-monorepo/apps/indexer/ponder.schema.ts`.

#### Create a ponder client and query

```
import { createClient, sql } from "@ponder/client";
import * as schema from "./schema";
 
// create a ponder client with specified schema
const client = createClient("https://api.ethcomments.xyz/sql", { schema });
 
// query the database for comments
const result = await client.db.select()
  .from(schema.comment)
  // filter comments by target uri
  .where(sql`${schema.comment.targetUri} = 'https://demo.ethcomments.xyz'`)
  // limit the result to 10
  .limit(10);

console.log(result)
```

See detailed explanation of ponder client at [Ponder client](https://ponder.sh/docs/query/client).

## 4. Contract Interaction

In some cases, such as bot development or custom integrations, you may want to directly interact with the CommentsV1 smart contract.

**Caveat**: Always check if you can achieve the same result by using our [Indexer API](/integration-options#2-indexer-api),
indexer service provides all comment data readily available for consumption, eliminating the need to manually scan the chain.
This significantly improves performance and reduces complexity in your application.

### Contract Addresses

See [COMMENTS_V1_ADDRESS](/sdk-reference/defaultExports/variables/COMMENTS_V1_ADDRESS)

### Post the comment as author

To show how to interact with the contract, we will create a simple example that simulates the author posting the comment and signed by app server.

- The author will post according to the [post comment flow](/post-comment-flow#1-author-pays-gas), and eventually pay for the gas.
- The app server will authorize the post by signing the comment data.

::::steps

#### Install tooling

In this example we will use `viem` and `@ecp.eth/sdk` to interact with the contract:

:::code-group

```bash [npm]
npm install viem "@ecp.eth/sdk"
```

```bash [yarn]
yarn add viem "@ecp.eth/sdk"
```

```bash [pnpm]
pnpm add viem "@ecp.eth/sdk"

```

:::

#### Simulate the App Server signing the post

For the app to sign and authorize posting, we will need the following information:

- The author's address
- The target chain for posting the comment
- The comment content
- The target URI of the comment

Let's create a function that signs comments for the app server. Here's the function signature:

```typescript
type sign = (
  authorAddress: Hex, 
  chain: Chain, 
  content: string, 
  targetUri: string
) => Promise<{
    signature: Hex
    commentData: CommentData
  }>
```

In the function body, we will start with retrieving the `nonce`.
Each author and app signer pair has a unique nonce that increments with each comment,
ensuring replay protection. We can use the `getNonce` function from the SDK to retrieve the nonce:

```typescript
import { getNonce } from '@ecp.eth/sdk'

const nonce = await getNonce({
  author: authorAddress,
  appSigner: appSigner.address,
  chain,
  transport,
});
```

Now with enough info we will get the comment data ready for signing.
Create a `CommentData` object with the provided info and the `nonce`:

```typescript
const commentData = createCommentData({
  content,
  targetUri,
  // we are posting a top level comment, so no parentId
  parentId: undefined,
  author: authorAddress,
  appSigner: appSigner.address,
  nonce,
});
```

Then create a typed data structure from `commentData` according to EIP-712:

```typescript
const typedCommentData = createCommentTypedData({
  commentData,
  chainId: chain.id,
});
```

Finally, sign the typed data using the app signer's private key and return both `signature` and `commentData`:

```typescript
const signature = await appSigner.signTypedData(typedCommentData);

return {
  signature,
  commentData,
}
```

Now we finished the App Server signing process, let's see how the author posting the comment.

#### Simulate the Author posting the comment

The signature for the function to create on author side is self-explanatory:

```typescript
type postComment(content: string, targetUri: string) => Promise<TransactionReceipt>
```

We will start by sending the comment data to the App Server for signing.

In the real scenario, the client side posts the data to the server via HTTP or whatever transport of your choice,
usually the App Server is deployed by a different party to keep the private key secure.

However, to demonstrate the flow in this example, we'll directly call the `sign` function from the `AppServer` instance.

```typescript
const appSignedComment = await this.appServer.sign(authorSigner.address, anvil, content, targetUri)
```

Then we call the function on the contract to post the comment, and wait for the transaction to be mined:

```typescript
const tx = await commentsContract.write.postCommentAsAuthor([
  appSignedComment.commentData,
  appSignedComment.signature
], {
  account: walletClient.account
})

const receipt = await waitForTransactionReceipt(walletClient, {
  hash: tx
})

return receipt
```

#### Put everything together

Here is the complete example, with everything put together:

```typescript
import { http, createWalletClient, getContract, Hex, Chain, hashTypedData } from 'viem'
import { anvil } from 'viem/chains'
import { waitForTransactionReceipt } from 'viem/actions';
import { COMMENTS_V1_ADDRESS, createCommentData, createCommentTypedData, getNonce } from '@ecp.eth/sdk'
import { CommentsV1Abi } from '@ecp.eth/sdk/abis'
import { privateKeyToAccount } from 'viem/accounts'

// we started a local anvil node for this example,
// anvil is a local ethereum node that is used for testing and development.
// run `pnpm i && pnpm run dev` in /packages/protocol/ to start the node 
// with deployed contract
const transport = http('http://localhost:8545')

/**
 * The class simulate the app server that signs the comment.
 * In real scenario, the client side post the data to the server,
 * and the app signing process should be hide away from the client.
 */
class AppServer {
  private readonly appSignerPrivateKey = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80'
  private readonly appSigner = privateKeyToAccount(this.appSignerPrivateKey)

  /**
   * Sign the comment data as the app server
   * @param authorAddress - The address of the author of the comment
   * @param chain - The chain on which the comment is being posted
   * @param content - The content of the comment
   * @param targetUri - The URI of the target of the comment
   * @returns The signed comment data
   */
  async sign(authorAddress: Hex, chain: Chain, content: string, targetUri: string) {
    const appSigner = this.appSigner
  
    // we must retrieve the nonce from the contract for signing,
    // a unique nonce will be assigned per author per appSigner by the contract
    // if the nonce doesn't match, the verification of the signature later on contract
    // side will fail
    const nonce = await getNonce({
      author: authorAddress,
      appSigner: appSigner.address,
      chain,
      transport,
    });

    const commentData = createCommentData({
      content,
      targetUri,
      // we are posting a top level comment, so no parentId
      parentId: undefined,
      author: authorAddress,
      appSigner: appSigner.address,
      nonce,
    });

    // create a typed data according to EIP-712 for signing
    const typedCommentData = createCommentTypedData({
      commentData,
      chainId: chain.id,
    });

    const signature = await appSigner.signTypedData(typedCommentData);

    return {
      signature,
      commentData,
    };
  }
}

/**
 * The class simulate the author who posts the comment from client side
 */
class Author {
  private readonly authorPrivateKey = '0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d'
  private readonly authorSigner = privateKeyToAccount(this.authorPrivateKey)
  // Create wallet client for interacting with the contract
  private readonly walletClient = createWalletClient({
    chain: anvil,
    transport,
    account: this.authorSigner
  })
  // Get contract instance
  private readonly commentsContract = getContract({
    address: COMMENTS_V1_ADDRESS,
    abi: CommentsV1Abi,
    client: this.walletClient
  })

  constructor(private appServer: AppServer) {}

  async postComment(content: string, targetUri: string) {
    const authorSigner = this.authorSigner
    const walletClient = this.walletClient
    const commentsContract = this.commentsContract

    // we post the comment data over to app server, 
    // to get the app server signed comment data
    const appSignedComment = await this.appServer.sign(authorSigner.address, anvil, content, targetUri)
   
    // post comment data and app signature so the contract can verify the comment is authorized by the app
    const tx = await commentsContract.write.postCommentAsAuthor([
      appSignedComment.commentData,
      appSignedComment.signature
    ], {
      // postCommentAsAuthor transaction will be executed by author signer so the author will have to pay.
      account: walletClient.account
    })
  
    const receipt = await waitForTransactionReceipt(walletClient, {
      hash: tx
    })

    return receipt
  } 
}

(async () => {
  const author = new Author(new AppServer())
  console.log('author is posting the comment and paying for the gas...')
  const receipt = await author.postComment(
    "Somebody successfully finished the tutorial!", 
    "https://demo.ethcomments.xyz"
  )
  console.log('author has posted the comment and the transaction is mined, transaction hash: ', receipt.transactionHash)
})()
```

See [Protocol API Reference](/protocol-reference/CommentsV1) for more functions and details.

#### Congratulations! You've completed the tutorial!

::::

#### Next Steps

- Check out **gasless** [post comment flows](/post-comment-flow)

### Best Practices

1. Always use fresh nonces by querying them before each operation
2. Set reasonable deadlines (e.g., 1 hour from current time)
3. Implement proper error handling
4. Monitor gas costs and adjust gas limits accordingly
5. Consider implementing retry mechanisms for failed transactions
6. Keep private keys secure and never expose them in client-side code
7. While the contract doesn't impose rate limits, consider implementing application-level rate limiting to prevent spam and manage gas costs effectively.
8. Considering anti-spam measures
